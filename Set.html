<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			/*Set本身是一个构造函数，用来生产Set数据结构*/
			const s=new Set();
			[1,2,3,4,5,6,7].forEach(i=>s.add(i));
			console.log(s);  //Set(7) {1, 2, 3, 4, 5, 6, 7};
			for(let i of s){
				console.log(i); //1 2 3 4 5 6 7
			}
			/*Set结构不会添加重复的值，Set允许添加一个数组来初始化*/
			const set=new Set([1,2,3,3,4,5]); 
			console.log(set);  //Set(5) {1, 2, 3, 4, 5}
			console.log([...set]); // [1, 2, 3, 4, 5]
			
			/*使用set实现数组去重*/
			/*方法一：*/
			console.log([...new Set([1,2,3,4,4,4])]);//[1,2,3,4]
			/*方法二：*/
			function dedupe(array){
				return Array.from(new Set(array))
			}
			console.log(dedupe([1,2,2,2,3,1]));//[1,2,3]
			
			/*Set结构的实例有四个遍历方法，用于遍历成员*/
			let p=new Set(["red","blue","green"]);
			console.log(p);//Set(3) {"red", "blue", "green"}
			for(let item of p.values()){
				console.log(item);  //red blue green
			}
			for(let item of p.keys()){
				console.log(item);  //red blue green
			}
			for(let item of p.entries()){
				console.log(item); //["red", "red"] ["blue", "blue"] ["green", "green"]
			}
			for(let item of p){
				console.log(item)  //red blue green
			}
			/*使用Set很容易实现并集，交集和差集*/
			let g=new Set([1,2,3]);
			let h=new Set([2,3,4]);
			let union=new Set([...g,...h]);
			console.log(union); //Set(4) {1, 2, 3, 4}
			let intersect=new Set([...g].filter(x=>h.has(x)));
			console.log(intersect); // Set(2) {2, 3}
			let difference=new Set([...g].filter(x=>!h.has(x)));
			console.log(difference); //Set(1) {1}
			
			
		</script>
	</body>
</html>
